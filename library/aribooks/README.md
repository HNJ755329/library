# 目的・目標
* 自分の理解度の整理のために理解した事柄をまとめる。
* 蟻本の制覇。
* 蟻本には乗ってない手法を追加する。
* 最終的には自作のライブラリを作る。
# ToDo
* 手法に着目した分類と、解法に着目した分類がごっちゃになってるのでいい感じに分類する。
* 計算量を示す
* 典型問題と関連付ける。
# DP
再帰関数 -> 再帰関数のメモ化 -> メモの直接操作の順番でDPを導入している。
DPになれないうちは再帰関数を考えつつ、慣れてきたら直接DPを操作する。
* スライド最小値
* ナップサック問題
* 個数制限なしナップサック問題
* 個数制限付きナップサック問題
* 桁DP
* 最長増加部分列
* 部分和問題
* 全方位木DP
# データ構造
* Union Find
* Segment tree
* BIT(Segment treeの機能を絞ったもの)
** 転倒数、反転数、バブルソートの操作回数
# グラフ
* DFS
* BFS
* A*-algorithm
* ベルマンフォード法
* Dijkstra
* ワーシャルフロイド法
* 最小全域木(Prim法)
* 最小全域木(クラスカル法)
* LCA

# 幾何
基本的にテンプレートはっておしまい。
# 最大流
ブラックボックス化したまま赤コーダーになれるらしいから後回し。
# 数学
* GCD(Greatest-Common-Divisor:最大公約数)
* LCM(Least-Common-Multiple:最小公倍数)

g++17以降なら`gcd(x,y)`,`lcm(x,y)`は`std`に含まれているが、
atcoderなどのコンテストサイトはg++14等なので
自作する必要がある。
また、値によってはLCMは`long long int`でも収まらないことがある。
その場合は`std::map`で素因数分解したまま値を保持することが有用。
* Modint
* 素因数分解
* 素数判定
* 組み合わせ
* 階乗
* フィボナッチ数列（再帰、DP、行列）
* 包除原理
* メビウスの反転公式(周期的でない文字列の数え上げ)
# 文字列
* z-Algorithm
# 貪欲法
* 区間スケジューリング問題
# ゲーム
* Nim
* grundy数
* 競プロのゲーム問題はNimとgrundy数に帰着できる。遷移状態さえわかれば愚直にgrundy数で計算できる。(計算量を無視すれば)
# テクニック
* しゃくとり法
* 二分探索
# 分割統治法
* 最近点対問題
## 区間最小値問題
* RMQ(Segment tree)
* Sparse Table
* スライド最小値（最大値）
# マラソン
* ビームサーチ